<?xml version="1.0" encoding='UTF-8'?>
<!DOCTYPE hibernate-mapping PUBLIC
                            "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
                            "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd" >
<hibernate-mapping>

    <query name="prefetchCustomerHierarchy">
        <![CDATA[from org.mifos.customers.business.CustomerBO as c
                left outer join fetch c.customerAddressDetail
                 left outer join fetch c.historicalData
                  left outer join fetch c.customerMeeting
                left outer join fetch c.groupPerformanceHistory gph
                 left outer join fetch gph.loanCounters
                left outer join fetch c.customerDetail
                left outer join fetch c.clientPerformanceHistory cph
                 left outer join fetch cph.loanCounters
                where c.office.id = :BRANCH_ID
                and c.customerStatus.id in (3,4,9,10,13)
                and (c.searchId = :SEARCH_ID or c.searchId like :SEARCH_ID2)]]>
    </query>

    <query name="prefetchAccountData">
        <![CDATA[from org.mifos.accounts.business.AccountBO as a
                left outer join fetch a.loanSummary
                left outer join fetch a.performanceHistory
                left outer join fetch a.loanArrearsAgingEntity
                left outer join fetch a.maxMinLoanAmount
                left outer join fetch a.maxMinNoOfInstall
                left outer join fetch a.loanMeeting lm
                left outer join fetch lm.meetingDetails md
                left outer join fetch md.meetingRecurrence
                left outer join fetch a.savingsPerformance
                inner join a.customer c
                where c.office.id = :BRANCH_ID
                and c.customerStatus.id in (3,4,9,10,13)
                and a.id in (:ACCOUNT_IDS)
                and (c.searchId = :SEARCH_ID or c.searchId like :SEARCH_ID2)]]>
    </query>

    <query name="prefetchLoanSchedules">
        <![CDATA[from org.mifos.accounts.loan.business.LoanBO as la
                inner join fetch la.accountActionDates aad
                left outer join fetch aad.accountFeesActionDetails
                inner join la.customer c
                where c.office.id = :BRANCH_ID
                and c.customerStatus.id in (3,4,9,10,13)
                and la.id in (:ACCOUNT_IDS)
                and (c.searchId = :SEARCH_ID or c.searchId like :SEARCH_ID2)
                and la.accountState.id in (3, 4, 5, 9)]]>
    </query>

    <query name="prefetchCustomerSchedules">
        <![CDATA[from org.mifos.customers.business.CustomerAccountBO as ca
                inner join fetch ca.accountActionDates aad
                left outer join fetch aad.accountFeesActionDetails
                inner join ca.customer c
                where c.office.id = :BRANCH_ID
                and ca.id in (:ACCOUNT_IDS)
                and c.customerStatus.id in (3,4,9,10,13)
                and (c.searchId = :SEARCH_ID or c.searchId like :SEARCH_ID2)]]>
    </query>

    <query name="prefetchAccountFeeDetails">
        <![CDATA[from org.mifos.accounts.business.AccountBO as a
                inner join fetch a.accountFees af
                inner join fetch af.fees f
                inner join fetch f.feeFrequency ff
                left outer join fetch ff.feeMeetingFrequency fmf
                left outer join fetch fmf.meetingDetails md
                left outer join fetch md.meetingRecurrence
                inner join a.customer c
                where c.office.id = :BRANCH_ID
                and a.id in (:ACCOUNT_IDS)
                and c.customerStatus.id in (3,4,9,10,13)
                and (c.searchId = :SEARCH_ID or c.searchId like :SEARCH_ID2)]]>
    </query>


    <query name="ClientAttendance.getAttendanceForClientsOnMeetingDate">
       <![CDATA[select clientAttendance from org.mifos.customers.client.business.ClientAttendanceBO clientAttendance
       inner join clientAttendance.customer c
       where c.office.id = :BRANCH_ID
       and c.searchId like :SEARCH_ID
       and c.customerStatus.id in (3,4,9,10,13)
       and clientAttendance.meetingDate = :MEETING_DATE ]]>
    </query>

    <sql-query name="findCustomerWithNoAssocationsLoaded">
        <return-scalar column="customerId" type="integer" />
        <return-scalar column="parentCustomerId" type="integer" />
        <return-scalar column="levelId" type="short" />
        <return-scalar column="name" type="string" />
        <return-scalar column="searchId" type="string" />
        <return-scalar column="branchId" type="short" />
        <![CDATA[
            select c.customer_id as customerId,
                    c.parent_customer_id as parentCustomerId,
                    c.customer_level_id as levelId,
                    c.display_name as name,
                    c.search_id as searchId,
                    c.branch_id as branchId
            from customer c
            where c.customer_id = :CUSTOMER_ID
            and c.status_id in (3 , 4 , 9 , 10 , 13)
        ]]>
    </sql-query>

    <!-- start of retrieve collectionsheet sql-queries -->

    <sql-query name="findCustomerAtTopOfHierarchyAsDto">
        <return-scalar column="customerId" type="integer" />
        <return-scalar column="parentCustomerId" type="integer" />
        <return-scalar column="levelId" type="short" />
        <return-scalar column="name" type="string" />
        <return-scalar column="searchId" type="string" />
        <return-scalar column="branchId" type="short" />
        <return-scalar column="attendanceId" type="short" />
        <![CDATA[
            select c.customer_id as customerId,
                    c.parent_customer_id as parentCustomerId,
                    c.customer_level_id as levelId,
                    c.display_name as name,
                    c.search_id as searchId,
                    c.branch_id as branchId,
                    ca.attendance as attendanceId
            from customer c
            left outer join customer_attendance ca on c.customer_id = ca.customer_id and ca.meeting_date = date(:TRANSACTION_DATE)
            where c.customer_id = :CUSTOMER_ID
            and c.status_id in (3 , 4 , 9 , 10 , 13)
        ]]>
    </sql-query>

    <sql-query name="findCustomersWithinHierarchyAsDto">
        <return-scalar column="customerId" type="integer" />
        <return-scalar column="parentCustomerId" type="integer" />
        <return-scalar column="levelId" type="short" />
        <return-scalar column="name" type="string" />
        <return-scalar column="searchId" type="string" />
        <return-scalar column="branchId" type="short" />
        <return-scalar column="attendanceId" type="short" />
        <![CDATA[
            select c.customer_id as customerId,
                    c.parent_customer_id as parentCustomerId,
                    c.customer_level_id as levelId,
                    c.display_name as name,
                    c.search_id as searchId,
                    c.branch_id as branchId,
                    ca.attendance as attendanceId
            from customer c
            left outer join customer_attendance ca on c.customer_id = ca.customer_id and ca.meeting_date = date(:TRANSACTION_DATE)
            where c.branch_id = :BRANCH_ID
            and c.search_id like :SEARCH_ID
            and c.status_id in (3 , 4 , 9 , 10 , 13)
            order by c.search_id
        ]]>
    </sql-query>

    <!-- loan queries for collection sheet -->
    <sql-query name="findLoanDisbursementsforCustomerAtTopOfHierarchyAsDto">
        <return-scalar column="customerId" type="integer" />
        <return-scalar column="accountId" type="integer" />
        <return-scalar column="accountStateId" type="short" />
        <return-scalar column="productShortName" type="string" />
        <return-scalar column="productId" type="short" />
        <return-scalar column="currencyId" type="short" />
        <return-scalar column="disbursementAmount" type="big_decimal" />
        <return-scalar column="payInterestAtDisbursement" type="short" />
        <![CDATA[
        select c.customer_id as customerId, a.account_id as accountId, a.account_state_id as accountStateId, po.prd_offering_short_name as productShortName, po.prd_offering_id as productId,
                la.loan_amount_currency_id as currencyId, la.loan_amount as disbursementAmount, la.interest_at_disb as payInterestAtDisbursement
                from loan_account la
                inner join account a on la.account_id=a.account_id
                inner join customer c on a.customer_id=c.customer_id
                inner join prd_offering po on la.prd_offering_id=po.prd_offering_id
                where c.branch_id=:BRANCH_ID
                and c.customer_id = :CUSTOMER_ID
                and c.status_id in (3 , 4 , 9 , 10 , 13)
                and (a.account_state_id in (3 , 4)) and date(:TRANSACTION_DATE) >= la.disbursement_date
        ]]>
    </sql-query>
    
    
    <!-- sivaji:hugotechnologies -->
     
      <sql-query name="findPrintDetailsAsDto">
        <return-scalar column="paymentId" type="integer" />
        <return-scalar column="customerId" type="integer" />
        <return-scalar column="customerName" type="string" />
        <return-scalar column="accountId" type="integer" />
        <return-scalar column="productName" type="string" />
        <return-scalar column="amount" type="big_decimal" />
        <return-scalar column="principal" type="big_decimal" />
        <return-scalar column="interest" type="big_decimal" />
        <![CDATA[Select paymentId,customerId,customerName,accountId,productName,amount,principal,interest from customer_payments 
        where customerid=:CUSTOMER_ID and paymentdate=date(:TRANSACTION_DATE)
 			]]>
    </sql-query>

    <sql-query name="findLoanDisbursementsforCustomerHierarchyAsDto">
        <return-scalar column="customerId" type="integer" />
        <return-scalar column="accountId" type="integer" />
        <return-scalar column="accountStateId" type="short" />
        <return-scalar column="productShortName" type="string" />
        <return-scalar column="productId" type="short" />
        <return-scalar column="currencyId" type="short" />
        <return-scalar column="disbursementAmount" type="big_decimal" />
        <return-scalar column="payInterestAtDisbursement" type="short" />
        <![CDATA[
        select c.customer_id as customerId, a.account_id as accountId, a.account_state_id as accountStateId, po.prd_offering_short_name as productShortName, po.prd_offering_id as productId,
                la.loan_amount_currency_id as currencyId, la.loan_amount as disbursementAmount, la.interest_at_disb as payInterestAtDisbursement
                from loan_account la
                inner join account a on la.account_id=a.account_id
                inner join customer c on a.customer_id=c.customer_id
                inner join prd_offering po on la.prd_offering_id=po.prd_offering_id
                where c.branch_id=:BRANCH_ID
                and c.search_id like :SEARCH_ID
                and c.status_id in (3 , 4 , 9 , 10 , 13)
                and (a.account_state_id in (3 , 4)) and date(:TRANSACTION_DATE) >= la.disbursement_date
        ]]>
    </sql-query>

    <sql-query name="findLoanRepaymentsforCustomerAtTopOfHierarchyAsDto">
        <return-scalar column="customerId" type="integer" />
        <return-scalar column="accountId" type="integer" />
        <return-scalar column="accountStateId" type="short" />
        <return-scalar column="productShortName" type="string" />
        <return-scalar column="productId" type="short" />
        <return-scalar column="currencyId" type="short" />
        <return-scalar column="principalDue" type="big_decimal" />
        <return-scalar column="principalPaid" type="big_decimal" />
        <return-scalar column="interestDue" type="big_decimal" />
        <return-scalar column="interestPaid" type="big_decimal" />
        <return-scalar column="penaltyDue" type="big_decimal" />
        <return-scalar column="penaltyPaid" type="big_decimal" />
        <return-scalar column="miscFeesDue" type="big_decimal" />
        <return-scalar column="miscFeesPaid" type="big_decimal" />
        <return-scalar column="miscPenaltyDue" type="big_decimal" />
        <return-scalar column="miscPenaltyPaid" type="big_decimal" />
        <![CDATA[
            select c.customer_id as customerId, a.account_id as accountId, a.account_state_id as accountStateId, po.prd_offering_short_name as productShortName, po.prd_offering_id as productId, lse.principal_currency_id as currencyId,
                    sum(lse.principal) as principalDue,
                    sum(lse.principal_paid) as principalPaid,
                    sum(lse.interest) as interestDue,
                    sum(lse.interest_paid) as interestPaid,
                    sum(lse.penalty) as penaltyDue,
                    sum(lse.penalty_paid) as penaltyPaid,
                    sum(lse.misc_fees) as miscFeesDue,
                    sum(lse.misc_fees_paid) as miscFeesPaid,
                    sum(lse.misc_penalty) as miscPenaltyDue,
                    sum(lse.misc_penalty_paid) as miscPenaltyPaid
            from loan_schedule as lse
            join loan_account l on lse.account_id = l.account_id
            join account a on l.account_id = a.account_id
            join customer c on a.customer_id = c.customer_id
            join prd_offering po on l.prd_offering_id = po.prd_offering_id
            where lse.action_date <= date(:TRANSACTION_DATE)
            and lse.payment_status= 0
            and c.customer_id = :CUSTOMER_ID
            and c.branch_id = :BRANCH_ID
            and c.status_id in (3,4,9,10,13)
            and a.account_state_id in (5, 9)
            group by c.customer_id, a.account_id, a.account_state_id, po.prd_offering_short_name, po.prd_offering_id, lse.principal_currency_id
        ]]>
    </sql-query>

    <sql-query name="findLoanRepaymentsforCustomerHierarchyAsDto">
        <return-scalar column="customerId" type="integer" />
        <return-scalar column="accountId" type="integer" />
        <return-scalar column="accountStateId" type="short" />
        <return-scalar column="productShortName" type="string" />
        <return-scalar column="productId" type="short" />
        <return-scalar column="currencyId" type="short" />
        <return-scalar column="principalDue" type="big_decimal" />
        <return-scalar column="principalPaid" type="big_decimal" />
        <return-scalar column="interestDue" type="big_decimal" />
        <return-scalar column="interestPaid" type="big_decimal" />
        <return-scalar column="penaltyDue" type="big_decimal" />
        <return-scalar column="penaltyPaid" type="big_decimal" />
        <return-scalar column="miscFeesDue" type="big_decimal" />
        <return-scalar column="miscFeesPaid" type="big_decimal" />
        <return-scalar column="miscPenaltyDue" type="big_decimal" />
        <return-scalar column="miscPenaltyPaid" type="big_decimal" />
        <![CDATA[
            select c.customer_id as customerId, a.account_id as accountId, a.account_state_id as accountStateId, po.prd_offering_short_name as productShortName, po.prd_offering_id as productId, lse.principal_currency_id as currencyId,
                    sum(lse.principal) as principalDue,
                    sum(lse.principal_paid) as principalPaid,
                    sum(lse.interest) as interestDue,
                    sum(lse.interest_paid) as interestPaid,
                    sum(lse.penalty) as penaltyDue,
                    sum(lse.penalty_paid) as penaltyPaid,
                    sum(lse.misc_fees) as miscFeesDue,
                    sum(lse.misc_fees_paid) as miscFeesPaid,
                    sum(lse.misc_penalty) as miscPenaltyDue,
                    sum(lse.misc_penalty_paid) as miscPenaltyPaid
            from loan_schedule as lse
            join loan_account l on lse.account_id = l.account_id
            join account a on l.account_id = a.account_id
            join customer c on a.customer_id = c.customer_id
            join prd_offering po on l.prd_offering_id = po.prd_offering_id
            where lse.action_date <= date(:TRANSACTION_DATE)
            and lse.payment_status= 0
            and c.search_id like :SEARCH_ID
            and c.branch_id = :BRANCH_ID
            and c.status_id in (3,4,9,10,13)
            and a.account_state_id in (5, 9)
            group by c.customer_id, a.account_id, a.account_state_id, po.prd_offering_short_name, po.prd_offering_id, lse.principal_currency_id
        ]]>
    </sql-query>

    <sql-query name="findActiveLoansforCustomerHierarchyAsDto">
        <return-scalar column="customerId" type="integer" />
        <return-scalar column="accountId" type="integer" />
        <return-scalar column="accountStateId" type="short" />
        <return-scalar column="productShortName" type="string" />
        <return-scalar column="productId" type="short" />
        <return-scalar column="currencyId" type="short" />
        <return-scalar column="principalDue" type="big_decimal" />
        <return-scalar column="principalPaid" type="big_decimal" />
        <return-scalar column="interestDue" type="big_decimal" />
        <return-scalar column="interestPaid" type="big_decimal" />
        <return-scalar column="penaltyDue" type="big_decimal" />
        <return-scalar column="penaltyPaid" type="big_decimal" />
        <return-scalar column="miscFeesDue" type="big_decimal" />
        <return-scalar column="miscFeesPaid" type="big_decimal" />
        <return-scalar column="miscPenaltyDue" type="big_decimal" />
        <return-scalar column="miscPenaltyPaid" type="big_decimal" />
        <![CDATA[
            select c.customer_id as customerId, a.account_id as accountId, a.account_state_id as accountStateId, po.prd_offering_short_name as productShortName, po.prd_offering_id as productId, l.loan_balance_currency_id as currencyId,
                    0.0 as principalDue,
                    0.0 as principalPaid,
                    0.0 as interestDue,
                    0.0 as interestPaid,
                    0.0 as penaltyDue,
                    0.0 as penaltyPaid,
                    0.0 as miscFeesDue,
                    0.0 as miscFeesPaid,
                    0.0 as miscPenaltyDue,
                    0.0 as miscPenaltyPaid
            from loan_account as l
            join account a on l.account_id = a.account_id
            join customer c on a.customer_id = c.customer_id
            join prd_offering po on l.prd_offering_id = po.prd_offering_id
            where c.search_id like :SEARCH_ID
            and c.branch_id = :BRANCH_ID
            and c.status_id in (3,4,9,10,13)
            and a.account_state_id in (5, 9)
            group by c.customer_id, a.account_id, a.account_state_id, po.prd_offering_short_name, po.prd_offering_id
        ]]>
    </sql-query>

    <sql-query name="findOutstandingFeesForLoansOnCustomerAtTopOfHierarchyAsDto">
        <return-scalar column="customerId" type="integer" />
        <return-scalar column="accountId" type="integer" />
        <return-scalar column="currencyId" type="short" />
        <return-scalar column="feeAmountDue" type="big_decimal" />
        <return-scalar column="feeAmountPaid" type="big_decimal" />
        <![CDATA[
            select c.customer_id as customerId, a.account_id as accountId,
                    lfs.amount_currency_id as currencyId,
                    sum(lfs.amount) as feeAmountDue,
                    sum(lfs.amount_paid) as feeAmountPaid
            from loan_schedule as lse
            join loan_fee_schedule lfs on lse.id = lfs.id
            join loan_account l on lse.account_id = l.account_id
            join account a on l.account_id = a.account_id
            join customer c on a.customer_id = c.customer_id
            join prd_offering po on l.prd_offering_id = po.prd_offering_id
            where lse.action_date <= date(:TRANSACTION_DATE)
            and lse.payment_status= 0
            and c.customer_id = :CUSTOMER_ID
            and c.branch_id = :BRANCH_ID
            and c.status_id in (3,4,9,10,13)
            and a.account_state_id in (5, 9)
            group by c.customer_id, a.account_id, lfs.amount_currency_id
        ]]>
    </sql-query>

    <sql-query name="findOutstandingFeesForLoansOnCustomerHierarchyAsDto">
        <return-scalar column="customerId" type="integer" />
        <return-scalar column="accountId" type="integer" />
        <return-scalar column="currencyId" type="short" />
        <return-scalar column="feeAmountDue" type="big_decimal" />
        <return-scalar column="feeAmountPaid" type="big_decimal" />
        <![CDATA[
            select c.customer_id as customerId, a.account_id as accountId,
                    lfs.amount_currency_id as currencyId,
                    sum(lfs.amount) as feeAmountDue,
                    sum(lfs.amount_paid) as feeAmountPaid
            from loan_schedule as lse
            join loan_fee_schedule lfs on lse.id = lfs.id
            join loan_account l on lse.account_id = l.account_id
            join account a on l.account_id = a.account_id
            join customer c on a.customer_id = c.customer_id
            join prd_offering po on l.prd_offering_id = po.prd_offering_id
            where lse.action_date <= date(:TRANSACTION_DATE)
            and lse.payment_status= 0
            and c.search_id like :SEARCH_ID
            and c.branch_id = :BRANCH_ID
            and c.status_id in (3,4,9,10,13)
            and a.account_state_id in (5, 9)
            group by c.customer_id, a.account_id, lfs.amount_currency_id
        ]]>
    </sql-query>

    <!-- customer account queries for collection sheet -->
    <!--
        Note: because of issue 2595 "and cs.currency_id is null" has been
        added to this query Could be taken out if data on customer_schedule
        pre about 2008-01-05 is removed
    -->
    <sql-query
        name="findAccountCollectionsOnCustomerAccountForCustomerHierarchyAsDto">
        <return-scalar column="customerId" type="integer" />
        <return-scalar column="accountId" type="integer" />
        <return-scalar column="currencyId" type="short" />
        <return-scalar column="miscFeesDue" type="big_decimal" />
        <return-scalar column="miscFeesPaid" type="big_decimal" />
        <return-scalar column="miscPenaltyDue" type="big_decimal" />
        <return-scalar column="miscPenaltyPaid" type="big_decimal" />
        <![CDATA[
            select c.customer_id as customerId, a.account_id as accountId, cs.misc_fees_currency_id as currencyId,
                    sum(cs.misc_fees) as miscFeesDue,
                    sum(cs.misc_fees_paid) as miscFeesPaid,
                    sum(cs.misc_penalty) as miscPenaltyDue,
                    sum(cs.misc_penalty_paid) as miscPenaltyPaid
            from customer_schedule as cs
            join account a on cs.account_id = a.account_id
            join customer c on a.customer_id = c.customer_id
            where cs.action_date <= date(:TRANSACTION_DATE)
            and cs.payment_status= 0
            and c.search_id like :SEARCH_ID
            and c.branch_id = :BRANCH_ID
            and c.status_id in (3,4,9,10,13)
            and cs.currency_id is null
            group by c.customer_id, a.account_id, cs.misc_fees_currency_id
        ]]>
    </sql-query>

    <!--
        Note: because of issue 2595 "and cs.currency_id is null" has been
        added to this query Could be taken out if data on customer_schedule
        pre about 2008-01-05 is removed
    -->
    <sql-query
        name="findAccountCollectionsOnCustomerAccountForTopCustomerOfHierarchy">
        <return-scalar column="customerId" type="integer" />
        <return-scalar column="accountId" type="integer" />
        <return-scalar column="currencyId" type="short" />
        <return-scalar column="miscFeesDue" type="big_decimal" />
        <return-scalar column="miscFeesPaid" type="big_decimal" />
        <return-scalar column="miscPenaltyDue" type="big_decimal" />
        <return-scalar column="miscPenaltyPaid" type="big_decimal" />
        <![CDATA[
            select c.customer_id as customerId, a.account_id as accountId, cs.misc_fees_currency_id as currencyId,
                    sum(cs.misc_fees) as miscFeesDue,
                    sum(cs.misc_fees_paid) as miscFeesPaid,
                    sum(cs.misc_penalty) as miscPenaltyDue,
                    sum(cs.misc_penalty_paid) as miscPenaltyPaid
            from customer_schedule as cs
            join account a on cs.account_id = a.account_id
            join customer c on a.customer_id = c.customer_id
            where cs.action_date <= date(:TRANSACTION_DATE)
            and cs.payment_status= 0
            and c.customer_id = :CUSTOMER_ID
            and c.status_id in (3,4,9,10,13)
            and cs.currency_id is null
            group by c.customer_id, a.account_id, cs.misc_fees_currency_id
        ]]>
    </sql-query>

    <sql-query
        name="findOutstandingFeesForCustomerAccountOnCustomerHierarchyAsDto">
        <return-scalar column="customerId" type="integer" />
        <return-scalar column="accountId" type="integer" />
        <return-scalar column="currencyId" type="short" />
        <return-scalar column="feeAmountDue" type="big_decimal" />
        <return-scalar column="feeAmountPaid" type="big_decimal" />
        <![CDATA[
            select c.customer_id as customerId, a.account_id as accountId,
                      cfs.amount_currency_id as currencyId,
                    sum(cfs.amount) as feeAmountDue,
                    sum(cfs.amount_paid) as feeAmountPaid
            from customer_schedule as cs
            join customer_fee_schedule cfs on cfs.id = cs.id
            join account a on cs.account_id = a.account_id
            join customer c on a.customer_id = c.customer_id
            where cs.action_date <= date(:TRANSACTION_DATE)
            and cs.payment_status= 0
            and c.search_id like :SEARCH_ID
            and c.branch_id = :BRANCH_ID
            and c.status_id in (3,4,9,10,13)
            group by c.customer_id, a.account_id, cfs.amount_currency_id
        ]]>
    </sql-query>

    <sql-query
        name="findOutstandingCustomerAccountFeesForTopCustomerOfHierarchyAsDto">
        <return-scalar column="customerId" type="integer" />
        <return-scalar column="accountId" type="integer" />
        <return-scalar column="currencyId" type="short" />
        <return-scalar column="feeAmountDue" type="big_decimal" />
        <return-scalar column="feeAmountPaid" type="big_decimal" />
        <![CDATA[
            select c.customer_id as customerId, a.account_id as accountId,
                      cfs.amount_currency_id as currencyId,
                    sum(cfs.amount) as feeAmountDue,
                    sum(cfs.amount_paid) as feeAmountPaid
            from customer_schedule as cs
            join customer_fee_schedule cfs on cfs.id = cs.id
            join account a on cs.account_id = a.account_id
            join customer c on a.customer_id = c.customer_id
            where cs.action_date <= date(:TRANSACTION_DATE)
            and cs.payment_status= 0
            and c.customer_id = :CUSTOMER_ID
            and c.status_id in (3,4,9,10,13)
            group by c.customer_id, a.account_id, cfs.amount_currency_id
        ]]>
    </sql-query>

    <!--  Loan disbursement queries for collection sheet -->
    <sql-query name="findFirstLoanSchedule">
        <return-scalar column="id" type="integer" />
        <return-scalar column="principalDue" type="big_decimal" />
        <return-scalar column="principalPaid" type="big_decimal" />
        <return-scalar column="interestDue" type="big_decimal" />
        <return-scalar column="interestPaid" type="big_decimal" />
        <return-scalar column="penaltyDue" type="big_decimal" />
        <return-scalar column="penaltyPaid" type="big_decimal" />
        <return-scalar column="miscFeesDue" type="big_decimal" />
        <return-scalar column="miscFeesPaid" type="big_decimal" />
        <return-scalar column="miscPenaltyDue" type="big_decimal" />
        <return-scalar column="miscPenaltyPaid" type="big_decimal" />
        <![CDATA[
           select      lse.id as id,
                       lse.principal as principalDue,
                    lse.principal_paid as principalPaid,
                    lse.interest as interestDue,
                    lse.interest_paid as interestPaid,
                    lse.penalty as penaltyDue,
                    lse.penalty_paid as penaltyPaid,
                    lse.misc_fees as miscFeesDue,
                    lse.misc_fees_paid as miscFeesPaid,
                    lse.misc_penalty as miscPenaltyDue,
                    lse.misc_penalty_paid as miscPenaltyPaid
            from loan_schedule as lse
            where lse.account_id = :ACCOUNT_ID
              and lse.installment_id  = 1
        ]]>
    </sql-query>


    <!--
        queries around (mandatory and voluntary/ per_individual and
        complete_group) savings accounts applicable to center, group and
        clients. Except for findAllSavingAccountsForCustomerHierarchy, only
        active savings accounts are picked up as inactive accounts don't have
        a due amount shown (deposits for inactive savings accounts are allowed
        to be entered though.
    -->
    <sql-query
        name="findAllMandatorySavingAccountsForClientsOrGroupsWithCompleteGroupStatusForTopOfCustomerHierarchy">
        <return-scalar column="customerId" type="integer" />
        <return-scalar column="accountId" type="integer" />
        <return-scalar column="productId" type="short" />
        <return-scalar column="productShortName" type="string" />
        <return-scalar column="recommendedAmountUnitId" type="short" />
        <return-scalar column="currencyId" type="short" />
        <return-scalar column="depositDue" type="big_decimal" />
        <return-scalar column="depositPaid" type="big_decimal" />
        <![CDATA[
           select c.customer_id as customerId,
                       a.account_id as accountId,
                       po.prd_offering_id as productId,
                       po.prd_offering_short_name as productShortName,
                       s.recommended_amnt_unit_id as recommendedAmountUnitId,
                    sse.deposit_currency_id as currencyId,
                    sum(sse.deposit) as depositDue,
                    sum(sse.deposit_paid) as depositPaid
            from saving_schedule as sse
            join savings_account s on sse.account_id = s.account_id
            join account a on s.account_id = a.account_id
            join customer c on a.customer_id = c.customer_id
            join prd_offering po on s.prd_offering_id = po.prd_offering_id
            where sse.action_date <= date(:TRANSACTION_DATE)
            and sse.payment_status= 0
            and c.customer_id = :CUSTOMER_ID
            and c.status_id in (3,4,9,10,13)
            and a.account_state_id = 16
              and s.savings_type_id = 1
              and (c.customer_level_id = 1 or (c.customer_level_id = 2 and s.recommended_amnt_unit_id=2))
            group by c.customer_id, a.account_id, po.prd_offering_id, po.prd_offering_short_name, sse.deposit_currency_id, s.recommended_amnt_unit_id
            order by c.customer_id, a.account_id, po.prd_offering_name
        ]]>
    </sql-query>

    <sql-query
        name="findAllMandatorySavingAccountsForClientsOrGroupsWithCompleteGroupStatusForRestOfCustomerHierarchy">
        <return-scalar column="customerId" type="integer" />
        <return-scalar column="accountId" type="integer" />
        <return-scalar column="productId" type="short" />
        <return-scalar column="productShortName" type="string" />
        <return-scalar column="recommendedAmountUnitId" type="short" />
        <return-scalar column="currencyId" type="short" />
        <return-scalar column="depositDue" type="big_decimal" />
        <return-scalar column="depositPaid" type="big_decimal" />
        <![CDATA[
           select c.customer_id as customerId,
                       a.account_id as accountId,
                       po.prd_offering_id as productId,
                       po.prd_offering_short_name as productShortName,
                       s.recommended_amnt_unit_id as recommendedAmountUnitId,
                    sse.deposit_currency_id as currencyId,
                    sum(sse.deposit) as depositDue,
                    sum(sse.deposit_paid) as depositPaid
            from saving_schedule as sse
            join savings_account s on sse.account_id = s.account_id
            join account a on s.account_id = a.account_id
            join customer c on a.customer_id = c.customer_id
            join prd_offering po on s.prd_offering_id = po.prd_offering_id
            where sse.action_date <= date(:TRANSACTION_DATE)
            and sse.payment_status= 0
            and c.branch_id = :BRANCH_ID
            and c.search_id like :SEARCH_ID
            and c.status_id in (3,4,9,10,13)
            and a.account_state_id = 16
              and s.savings_type_id = 1
              and (c.customer_level_id = 1 or (c.customer_level_id = 2 and s.recommended_amnt_unit_id=2))
            group by c.customer_id, a.account_id, po.prd_offering_id, po.prd_offering_short_name, sse.deposit_currency_id, s.recommended_amnt_unit_id
            order by c.customer_id, a.account_id, po.prd_offering_name
        ]]>
    </sql-query>

    <sql-query
        name="findAllVoluntarySavingsAccountsForClientsAndGroupsWithCompleteGroupStatusForTopOfCustomerHierarchy">
        <return-scalar column="customerId" type="integer" />
        <return-scalar column="accountId" type="integer" />
        <return-scalar column="productId" type="short" />
        <return-scalar column="productShortName" type="string" />
        <return-scalar column="recommendedAmountUnitId" type="short" />
        <return-scalar column="currencyId" type="short" />
        <return-scalar column="depositDue" type="big_decimal" />
        <return-scalar column="depositPaid" type="big_decimal" />
        <![CDATA[
           select c.customer_id as customerId,
                       a.account_id as accountId,
                       po.prd_offering_id as productId,
                       po.prd_offering_short_name as productShortName,
                       s.recommended_amnt_unit_id as recommendedAmountUnitId,
                    sse.deposit_currency_id as currencyId,
                    s.recommended_amount as depositDue,
                    0 as depositPaid
            from saving_schedule as sse
            join savings_account s on sse.account_id = s.account_id
            join account a on s.account_id = a.account_id
            join customer c on a.customer_id = c.customer_id
            join prd_offering po on s.prd_offering_id = po.prd_offering_id
            where sse.action_date <= date(:TRANSACTION_DATE)
            and sse.payment_status= 0
            and c.customer_id = :CUSTOMER_ID
            and c.status_id in (3,4,9,10,13)
            and a.account_state_id = 16
              and s.savings_type_id = 2
              and (c.customer_level_id = 1 or (c.customer_level_id = 2 and s.recommended_amnt_unit_id=2))
            group by c.customer_id, a.account_id, po.prd_offering_id, po.prd_offering_short_name, sse.deposit_currency_id, s.recommended_amnt_unit_id
            order by c.customer_id, a.account_id, po.prd_offering_name
        ]]>
    </sql-query>

    <sql-query
        name="findAllVoluntarySavingsAccountsForClientsAndGroupsWithCompleteGroupStatusForRestOfCustomerHierarchy">
        <return-scalar column="customerId" type="integer" />
        <return-scalar column="accountId" type="integer" />
        <return-scalar column="productId" type="short" />
        <return-scalar column="productShortName" type="string" />
        <return-scalar column="recommendedAmountUnitId" type="short" />
        <return-scalar column="currencyId" type="short" />
        <return-scalar column="depositDue" type="big_decimal" />
        <return-scalar column="depositPaid" type="big_decimal" />
        <![CDATA[
           select c.customer_id as customerId,
                       a.account_id as accountId,
                       po.prd_offering_id as productId,
                       po.prd_offering_short_name as productShortName,
                       s.recommended_amnt_unit_id as recommendedAmountUnitId,
                    sse.deposit_currency_id as currencyId,
                    s.recommended_amount as depositDue,
                    0 as depositPaid
            from saving_schedule as sse
            join savings_account s on sse.account_id = s.account_id
            join account a on s.account_id = a.account_id
            join customer c on a.customer_id = c.customer_id
            join prd_offering po on s.prd_offering_id = po.prd_offering_id
            where sse.action_date <= date(:TRANSACTION_DATE)
            and sse.payment_status= 0
            and c.branch_id = :BRANCH_ID
            and c.search_id like :SEARCH_ID
            and c.status_id in (3,4,9,10,13)
            and a.account_state_id = 16
              and s.savings_type_id = 2
              and (c.customer_level_id = 1 or (c.customer_level_id = 2 and s.recommended_amnt_unit_id=2))
            group by c.customer_id, a.account_id, po.prd_offering_id, po.prd_offering_short_name, sse.deposit_currency_id, s.recommended_amnt_unit_id
            order by c.customer_id, a.account_id, po.prd_offering_name
        ]]>
    </sql-query>

    <sql-query
        name="findAllMandatorySavingsAccountsForCentersAndGroupsWithPerIndividualStatusForTopOfCustomerHierarchy">
        <return-scalar column="customerId" type="integer" />
        <return-scalar column="accountId" type="integer" />
        <return-scalar column="productId" type="short" />
        <return-scalar column="currencyId" type="short" />
        <return-scalar column="productShortName" type="string" />
        <return-scalar column="depositDue" type="big_decimal" />
        <return-scalar column="depositPaid" type="big_decimal" />
        <![CDATA[
            select a.account_id as accountId,
             sse.customer_id as customerId,
             po.prd_offering_id as productId,
             sse.deposit_currency_id as currencyId,
            po.prd_offering_short_name as productShortName,
             sum(sse.deposit) as depositDue,
             sum(sse.deposit_paid) as depositPaid
            from saving_schedule as sse
            join savings_account s on sse.account_id = s.account_id
            join account a on s.account_id = a.account_id
            join customer c on a.customer_id = c.customer_id
            join prd_offering po on s.prd_offering_id = po.prd_offering_id
            where sse.action_date <= date(:TRANSACTION_DATE)
            and sse.payment_status= 0
            and c.customer_id = :CUSTOMER_ID
            and c.status_id in (3,4,9,10,13)
            and a.account_state_id = 16
              and s.savings_type_id = 1
              and (c.customer_level_id = 3 or (c.customer_level_id = 2 and s.recommended_amnt_unit_id=1))
            group by a.account_id, sse.customer_id, po.prd_offering_id, po.prd_offering_short_name
              order by a.account_id, sse.customer_id
        ]]>
    </sql-query>

    <sql-query
        name="findAllMandatorySavingsAccountsForCentersAndGroupsWithPerIndividualStatusForRestOfCustomerHierarchy">
        <return-scalar column="customerId" type="integer" />
        <return-scalar column="accountId" type="integer" />
        <return-scalar column="productId" type="short" />
        <return-scalar column="currencyId" type="short" />
        <return-scalar column="productShortName" type="string" />
        <return-scalar column="depositDue" type="big_decimal" />
        <return-scalar column="depositPaid" type="big_decimal" />
        <![CDATA[
            select a.account_id as accountId,
             sse.customer_id as customerId,
             sse.deposit_currency_id as currencyId,
             po.prd_offering_id as productId,
            po.prd_offering_short_name as productShortName,
             sum(sse.deposit) as depositDue,
             sum(sse.deposit_paid) as depositPaid
            from saving_schedule as sse
            join savings_account s on sse.account_id = s.account_id
            join account a on s.account_id = a.account_id
            join customer c on a.customer_id = c.customer_id
            join prd_offering po on s.prd_offering_id = po.prd_offering_id
            where sse.action_date <= date(:TRANSACTION_DATE)
            and sse.payment_status= 0
            and c.branch_id = :BRANCH_ID
            and c.search_id like :SEARCH_ID
            and c.status_id in (3,4,9,10,13)
            and a.account_state_id = 16
              and s.savings_type_id = 1
              and (c.customer_level_id = 3 or (c.customer_level_id = 2 and s.recommended_amnt_unit_id=1))
            group by a.account_id, sse.customer_id, po.prd_offering_id, po.prd_offering_short_name
              order by a.account_id, sse.customer_id
        ]]>
    </sql-query>

    <sql-query
        name="findAllVoluntarySavingsAccountsForCentersAndGroupsWithPerIndividualStatusForTopOfCustomerHierarchy">
        <return-scalar column="customerId" type="integer" />
        <return-scalar column="accountId" type="integer" />
        <return-scalar column="productId" type="short" />
        <return-scalar column="currencyId" type="short" />
        <return-scalar column="productShortName" type="string" />
        <return-scalar column="depositDue" type="big_decimal" />
        <return-scalar column="depositPaid" type="big_decimal" />
        <![CDATA[
            select a.account_id as accountId,
             sse.customer_id as customerId,
             sse.deposit_currency_id as currencyId,
             po.prd_offering_id as productId,
               po.prd_offering_short_name as productShortName,
            s.recommended_amount as depositDue,
            0 as depositPaid
            from saving_schedule as sse
            join savings_account s on sse.account_id = s.account_id
            join account a on s.account_id = a.account_id
            join customer c on a.customer_id = c.customer_id
            join prd_offering po on s.prd_offering_id = po.prd_offering_id
            where sse.action_date <= date(:TRANSACTION_DATE)
            and sse.payment_status= 0
            and c.customer_id = :CUSTOMER_ID
            and c.status_id in (3,4,9,10,13)
            and a.account_state_id = 16
              and s.savings_type_id = 2
              and (c.customer_level_id = 3 or (c.customer_level_id = 2 and s.recommended_amnt_unit_id=1))
            group by a.account_id, sse.customer_id, po.prd_offering_id, po.prd_offering_short_name
              order by a.account_id, sse.customer_id
        ]]>
    </sql-query>

    <sql-query
        name="findAllVoluntarySavingsAccountsForCentersAndGroupsWithPerIndividualStatusForRestOfCustomerHierarchy">
        <return-scalar column="customerId" type="integer" />
        <return-scalar column="accountId" type="integer" />
        <return-scalar column="productId" type="short" />
        <return-scalar column="currencyId" type="short" />
        <return-scalar column="productShortName" type="string" />
        <return-scalar column="depositDue" type="big_decimal" />
        <return-scalar column="depositPaid" type="big_decimal" />
        <![CDATA[
            select a.account_id as accountId,
             sse.customer_id as customerId,
             sse.deposit_currency_id as currencyId,
             po.prd_offering_id as productId,
            po.prd_offering_short_name as productShortName,
             s.recommended_amount as depositDue,
            0 as depositPaid
            from saving_schedule as sse
            join savings_account s on sse.account_id = s.account_id
            join account a on s.account_id = a.account_id
            join customer c on a.customer_id = c.customer_id
            join prd_offering po on s.prd_offering_id = po.prd_offering_id
            where sse.action_date <= date(:TRANSACTION_DATE)
            and sse.payment_status= 0
            and c.branch_id = :BRANCH_ID
            and c.search_id like :SEARCH_ID
            and c.status_id in (3,4,9,10,13)
            and a.account_state_id = 16
              and s.savings_type_id = 2
              and (c.customer_level_id = 3 or (c.customer_level_id = 2 and s.recommended_amnt_unit_id=1))
            group by a.account_id, sse.customer_id, po.prd_offering_id, po.prd_offering_short_name
              order by a.account_id, sse.customer_id
        ]]>
    </sql-query>

    <sql-query name="findAllSavingAccountsForCustomerHierarchy">
        <return-scalar column="customerId" type="integer" />
        <return-scalar column="accountId" type="integer" />
        <return-scalar column="productId" type="short" />
        <return-scalar column="productShortName" type="string" />
        <return-scalar column="currencyId" type="short" />
        <return-scalar column="customerLevelId" type="short" />
        <return-scalar column="recommendedAmountUnitId" type="short" />
        <![CDATA[
            select c.customer_id as customerId,
            sa.account_id as accountId,
             po.prd_offering_id as productId,
            po.prd_offering_short_name as productShortName,
            sa.savings_balance_currency_id as currencyId,
            c.customer_level_id as customerLevelId,
            sa.recommended_amnt_unit_id as recommendedAmountUnitId
            from customer c
            join account a on a.customer_id = c.customer_id
            join savings_account sa on sa.account_id = a.account_id
            join prd_offering po on po.prd_offering_id = sa.prd_offering_id
            join savings_offering so on so.prd_offering_id = po.prd_offering_id
            where c.branch_id = :BRANCH_ID
            and (c.search_id = :SEARCH_ID_NO_PERCENTAGE or c.search_id like :SEARCH_ID)
            and c.status_id in (3,4,9,10,13)
            and a.account_state_id in (16, 18)
            and sa.activation_date <= date(:TRANSACTION_DATE)
              order by c.customer_id, po.prd_offering_short_name
        ]]>
    </sql-query>
</hibernate-mapping>
